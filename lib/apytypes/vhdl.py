import math
from pathlib import Path
from typing import TextIO

from apytypes._apytypes import APyFixedArray, APyFloatArray


def generate_rom(
    table: APyFixedArray | APyFloatArray,
    entity: str | None = None,
    address: APyFixedArray | APyFloatArray | None = None,
    frac_bits: int | None = None,
    ieee2008: bool = False,
    input_register: bool = False,
    output_register: bool = False,
    file: TextIO | None = None,
) -> None:
    """
    Generate VHDL for a ROM.

    .. versionadded:: 0.3

    Parameters
    ----------
    table : APyFixedArray, APyFloatArray
        The data in the ROM.
    entity : str, optional
        VHDL entity name.
    address : APyFixedArray, APyFloatArray, optional
        Addresses for the ROM. If not provided, sequential addressing from 0 is assumed.
    frac_bits : :class:`int`, optional
        If *ieee2008* is True and *address* is not provided, use this many fractional bits for address.
    ieee2008 : :class:`bool`, default: False
        Use ``ieee.fixed_pkg`` and/or ``ieee.float_pkg`` for the resulting ROM.
    input_register : :class:`bool`, default: False
        If ``True``, a register is added at the input of the ROM.
    output_register : :class:`bool`, default: False
        If ``True``, a register is added at the output of the ROM.
    file : file handle, optional
        File handle to write the file to. If not provided, a file ``entity.vhdl`` is used.
    """
    table = table.squeeze()
    if table.ndim != 1:
        raise TypeError("Can only create ROMs for 1D-tables.")
    number_of_table_values = table.shape[0]
    address_bits = math.ceil(math.log2(number_of_table_values))
    entity = entity or f"ROM_{address_bits}"

    if file:
        _write_rom(
            f=file,
            table=table,
            number_of_table_values=number_of_table_values,
            address_bits=address_bits,
            address=address,
            entity=entity,
            ieee2008=ieee2008,
            frac_bits=frac_bits,
            input_register=input_register,
            output_register=output_register,
        )
    else:
        filename = entity + ".vhdl"
        with Path(filename).open("w") as f:
            _write_rom(
                f=f,
                table=table,
                number_of_table_values=number_of_table_values,
                address_bits=address_bits,
                address=address,
                entity=entity,
                ieee2008=ieee2008,
                frac_bits=frac_bits,
                input_register=input_register,
                output_register=output_register,
            )


def _write_rom(
    f: TextIO,
    table: APyFixedArray | APyFloatArray,
    number_of_table_values: NotImplementedError,
    address_bits: int,
    address: APyFixedArray | APyFloatArray | None,
    entity: str,
    ieee2008: bool,
    frac_bits: int | None,
    input_register: bool,
    output_register: bool,
) -> None:
    table_values = table.to_bits()
    if address is None:
        address_values = range(number_of_table_values)
    else:
        address = address.squeeze()
        if address.shape != table.shape:
            raise TypeError(
                "table and address must have the same shape (after squeeze)"
            )
        address_values = address.to_bits()

    anyfloat = False
    anyfixed = False
    if ieee2008:
        if isinstance(table, APyFixedArray):
            data_end_index = -table.frac_bits
            data_start_index = table.int_bits - 1
            data_type = "sfixed"
            anyfixed = True
        else:
            data_end_index = table.man_bits
            data_start_index = table.exp_bits
            data_type = "float"
            anyfloat = True
        if isinstance(address, APyFixedArray):
            address_end_index = address.frac_bits
            address_start_index = address.int_bits - 1
            address_type = "sfixed"
            anyfixed = True
        elif isinstance(address, APyFloatArray):
            address_end_index = -address.man_bits
            address_start_index = address.exp_bits
            address_type = "float"
            anyfloat = True
        else:
            address_end_index = frac_bits or 0
            address_start_index = address_bits - address_end_index - 1
            address_type = "sfixed"
            anyfixed = True
    else:
        data_end_index = 0
        data_start_index = table.bits - 1
        data_type = "std_logic_vector"
        address_end_index = 0
        address_start_index = address_bits - 1
        address_type = "std_logic_vector"

    # Write the contents of the file
    f.write(f"-- {entity} generated by APyTypes\n")
    f.write("library ieee;\n")
    if input_register or output_register or not ieee2008:
        f.write("use ieee.std_logic_1164.all;\n")
    if anyfixed:
        f.write("use ieee.fixed_pkg.all;\n")
    if anyfloat:
        f.write("use ieee.float_pkg.all;\n")

    f.write("\n")

    f.write(f"entity {entity} is\n  port(\n")
    f.write(
        f"   address: in {address_type}({address_start_index} downto {address_end_index});\n"
    )
    if output_register:
        f.write("   clk: in std_logic;\n")
    f.write(f"   data: out {data_type}({data_start_index} downto {data_end_index})\n")
    f.write(");\nend entity;\n\n")
    f.write(f"architecture generated of {entity} is\n")
    f.write(
        f"  signal data_tmp: {data_type}({data_start_index} downto {data_end_index});\n"
    )
    f.write(
        f"   signal address_tmp: in {address_type}({address_start_index} downto {address_end_index});\n"
    )
    f.write("begin\n")
    if output_register:
        f.write("  process(clk)\n  begin\n  if rising_edge(clk) then\n")
        f.write("    address_tmp <= address;\n  end if;\n  end process;\n")
    else:
        f.write("  address_tmp <= address;\n")
    f.write("  with address_tmp select data_tmp <=\n")
    data_fmt_string = f'"{{:0{table.bits}b}}"'
    address_fmt_string = f'"{{:0{address_bits}b}}"'
    for i in range(number_of_table_values):
        f.write("    ")
        f.write(data_fmt_string.format(table_values[i]))
        f.write(" when ")
        f.write(address_fmt_string.format(address_values[i]))
        f.write(",\n")
    f.write("    (others => '-') when others;\n")
    if output_register:
        f.write("  process(clk)\n  begin\n  if rising_edge(clk) then\n")
        f.write("    data <= data_tmp;\n  end if;\n  end process;\n")
    else:
        f.write("  data <= data_tmp;\n")
    f.write("end architecture;\n")
